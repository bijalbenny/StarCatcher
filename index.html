<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Catcher Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom styles for the game */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
        }
        canvas {
            background-color: #a7d9ff; /* Sky blue background for canvas */
            border-radius: 1rem; /* Rounded corners for the canvas */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15); /* Soft shadow */
            display: block;
            width: 100%; /* Make canvas responsive */
            max-width: 800px; /* Max width for desktop */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 4/3; /* Standard game aspect ratio */
            touch-action: manipulation; /* Prevent default touch actions like double-tap zoom */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            padding: 1.5rem;
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
            max-width: 90%; /* Responsive container width */
        }
        .control-group {
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap on small screens */
            gap: 1rem;
            justify-content: center;
            align-items: center;
        }
        button {
            padding: 0.9rem 2rem; /* Increased padding */
            border-radius: 1rem; /* More rounded corners */
            font-weight: bold;
            transition: all 0.25s ease-in-out; /* Smoother transition */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.18); /* Stronger initial shadow */
            border: none;
            cursor: pointer; /* Indicate clickable */
            letter-spacing: 0.05em; /* Increased letter spacing */
            text-transform: uppercase; /* Uppercase text */
            font-size: 1.05rem; /* Slightly larger font */
            min-width: 160px; /* Ensure enough width for "Play Again?" */
        }
        button:hover {
            transform: translateY(-4px) scale(1.03); /* More pronounced lift and slight scale */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25); /* Stronger hover shadow */
        }
        button:active {
            transform: translateY(0) scale(0.97); /* Press down effect */
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); /* Smaller active shadow */
        }
        .btn-primary {
            background-color: #2ECC71; /* Brighter Green */
            color: white;
            border: 2px solid #27AE60; /* More defined border */
            background-image: linear-gradient(to bottom right, #2ECC71, #27AE60); /* Subtle gradient */
        }
        .btn-primary:hover {
            background-color: #27AE60; /* Darker green on hover */
            background-image: linear-gradient(to bottom right, #27AE60, #2ECC71); /* Reverse gradient on hover */
        }
        .btn-gemini { /* Style for Gemini API buttons */
            background-color: #8E44AD; /* Darker Purple */
            color: white;
            border: 2px solid #7D3C98;
            background-image: linear-gradient(to bottom right, #8E44AD, #7D3C98);
        }
        .btn-gemini:hover {
            background-color: #7D3C98;
            background-image: linear-gradient(to bottom right, #7D3C98, #8E44AD);
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100px; /* Fixed width for sliders */
            height: 8px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); /* Inner shadow for depth */
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px; /* Slightly larger thumb */
            height: 24px; /* Slightly larger thumb */
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3); /* More prominent thumb shadow */
            border: 2px solid #fff; /* White border for distinction */
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px; /* Slightly larger thumb */
            height: 24px; /* Slightly larger thumb */
            background: #4CAF50;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3); /* More prominent thumb shadow */
            border: 2px solid #fff; /* White border for distinction */
        }
        label {
            font-size: 0.9rem;
            color: #4a5568;
            font-weight: 500;
        }
        #message-box {
            background-color: #fff3cd;
            color: #856404;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1rem;
            text-align: center;
            font-weight: 600;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            /* display: none; */ /* Hidden by default, controlled by JS */
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #673AB7;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 0.5rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Styles for floating score/life changes */
        .score-feedback {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 0;
            animation: fadeUp 1s forwards;
            pointer-events: none; /* Allow clicks to pass through */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        .score-positive {
            color: #4CAF50; /* Green */
        }
        .score-negative {
            color: #f44336; /* Red */
        }
        @keyframes fadeUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-4">⭐ Star Catcher ⭐</h1>
        <canvas id="gameCanvas"></canvas>

        <div class="control-group">
            <div class="flex flex-col items-center">
                <label for="catcherSpeed">Catcher Speed:</label>
                <input type="range" id="catcherSpeed" min="2" max="15" value="7" class="accent-green-500">
            </div>
            <div class="flex flex-col items-center">
                <label for="starSpeed">Star Speed:</label>
                <input type="range" id="starSpeed" min="1" max="10" value="3" class="accent-blue-500">
            </div>
            <button id="startButton" class="btn-primary">Start Game</button>
        </div>

        <div class="control-group mt-4">
            <button id="getEncouragementButton" class="btn-gemini">✨ Get Encouragement ✨</button>
            <button id="getStarFactButton" class="btn-gemini">✨ Star Fact ✨</button>
        </div>

        <div class="flex items-center justify-center gap-4 text-xl font-semibold text-gray-700 mt-4">
            <span>Score: <span id="scoreDisplay" class="text-green-600">0</span></span>
            <span>Lives: <span id="livesDisplay" class="text-red-600">3</span></span>
        </div>

        <div id="message-box" class="mt-4"></div>
    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get control elements
        const startButton = document.getElementById('startButton');
        const catcherSpeedSlider = document.getElementById('catcherSpeed');
        const starSpeedSlider = document.getElementById('starSpeed');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const messageBox = document.getElementById('message-box');
        const getEncouragementButton = document.getElementById('getEncouragementButton');
        const getStarFactButton = document.getElementById('getStarFactButton');

        // Game state variables
        let gameRunning = false;
        let gamePaused = false; // Game will always be paused when not running
        let score = 0;
        let lives = 3;
        let animationFrameId; // To store the requestAnimationFrame ID

        // Catcher properties
        const catcher = {
            x: 0, // Will be set in setCanvasDimensions
            y: 0, // Will be set in setCanvasDimensions
            width: 100,
            height: 20,
            dx: 0,
            speed: parseInt(catcherSpeedSlider.value),
            originalWidth: 100
        };

        // Stars array
        let stars = [];
        let starFallSpeed = parseInt(starSpeedSlider.value);
        const starSpawnInterval = 1000; // Time in ms between new star spawns
        let lastStarSpawnTime = 0;

        // Power-up state
        let megaCatcherTimeoutId = null;
        const megaCatcherDuration = 5000; // 5 seconds

        // Tone.js Synths for sound effects, initialized once
        let starCatchSynth;
        let bombHitSynth;
        let gameOverSynth;
        let toneStarted = false;

        // --- Game Initialization and Setup ---

        // Function to set canvas dimensions based on parent container
        function setCanvasDimensions() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;

            canvas.width = Math.min(containerWidth * 0.9, 800);
            canvas.height = canvas.width * (3 / 4); // Maintain 4:3 aspect ratio

            // Adjust catcher position on resize
            catcher.x = canvas.width / 2 - catcher.width / 2;
            catcher.y = canvas.height - 60;
        }

        // Initial game setup or reset
        function initGame() {
            score = 0;
            lives = 3;
            stars = []; // Clear all falling items
            catcher.width = catcher.originalWidth; // Reset catcher width
            catcher.dx = 0; // Stop catcher movement
            
            // Clear any active power-up timeouts
            if (megaCatcherTimeoutId) {
                clearTimeout(megaCatcherTimeoutId);
                megaCatcherTimeoutId = null;
            }

            gameRunning = false;
            gamePaused = false; // Ensure game is paused when initialized
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            startButton.textContent = 'Start Game'; // Ensure button text is 'Start Game'
            showMessage("Press 'Start Game' to begin! Use Left/Right arrow keys to move.");
            draw(); // Redraw initial empty state

            // Reset last spawn time to ensure a delay before the first item appears
            lastStarSpawnTime = Date.now();
        }

        // --- Drawing Functions ---
        function drawCatcher() {
            ctx.beginPath();
            ctx.rect(catcher.x, catcher.y, catcher.width, catcher.height);
            ctx.fillStyle = '#4a90e2'; // Blue color for catcher
            ctx.fill();
            ctx.closePath();
        }

        function drawStar(star) {
            ctx.beginPath();
            const outerRadius = star.size / 2;
            const innerRadius = outerRadius / 2;
            const numPoints = 5;

            ctx.fillStyle = '#FFD700'; // Gold color for stars
            ctx.strokeStyle = '#DAA520'; // Darker gold for border
            ctx.lineWidth = 2;

            ctx.moveTo(star.x, star.y - outerRadius);

            for (let i = 0; i < numPoints; i++) {
                let angle = (i * Math.PI * 2 / numPoints) - (Math.PI / 2);
                ctx.lineTo(star.x + outerRadius * Math.cos(angle), star.y + outerRadius * Math.sin(angle));
                angle += (Math.PI / numPoints);
                ctx.lineTo(star.x + innerRadius * Math.cos(angle), star.y + innerRadius * Math.sin(angle));
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function drawBomb(bomb) {
            ctx.beginPath();
            ctx.arc(bomb.x, bomb.y, bomb.size / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#333333'; // Dark gray/black for bomb
            ctx.fill();
            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Draw a simple fuse
            ctx.beginPath();
            ctx.moveTo(bomb.x + bomb.size / 4, bomb.y - bomb.size / 2);
            ctx.lineTo(bomb.x + bomb.size / 2, bomb.y - bomb.size);
            ctx.strokeStyle = '#FF4500'; // Orange-red for fuse
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
        }

        function drawPowerUpStar(powerup) {
            ctx.beginPath();
            const outerRadius = powerup.size / 2;
            const innerRadius = outerRadius / 2;
            const numPoints = 5;

            ctx.fillStyle = '#8A2BE2'; // BlueViolet for power-up star
            ctx.strokeStyle = '#4B0082'; // Indigo for border
            ctx.lineWidth = 3; // Thicker border for emphasis

            ctx.moveTo(powerup.x, powerup.y - outerRadius);

            for (let i = 0; i < numPoints; i++) {
                let angle = (i * Math.PI * 2 / numPoints) - (Math.PI / 2);
                ctx.lineTo(powerup.x + outerRadius * Math.cos(angle), powerup.y + outerRadius * Math.sin(angle));
                angle += (Math.PI / numPoints);
                ctx.lineTo(powerup.x + innerRadius * Math.cos(angle), powerup.y + innerRadius * Math.sin(angle));
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Add a small "P" for Power-up
            ctx.fillStyle = 'white';
            ctx.font = `${powerup.size * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('P', powerup.x, powerup.y);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            drawCatcher();
            stars.forEach(item => {
                if (item.type === 'star') {
                    drawStar(item);
                } else if (item.type === 'bomb') {
                    drawBomb(item);
                } else if (item.type === 'powerup') {
                    drawPowerUpStar(item);
                }
            });
        }

        // --- Update Functions ---
        function updateCatcher() {
            catcher.x += catcher.dx;

            // Keep catcher within canvas bounds
            if (catcher.x < 0) {
                catcher.x = 0;
            }
            if (catcher.x + catcher.width > canvas.width) {
                catcher.x = canvas.width - catcher.width;
            }
        }

        function showFloatingFeedback(x, y, text, type) {
            const feedbackElement = document.createElement('div');
            feedbackElement.textContent = text;
            feedbackElement.classList.add('score-feedback');
            if (type === 'positive') {
                feedbackElement.classList.add('score-positive');
            } else if (type === 'negative') {
                feedbackElement.classList.add('score-negative');
            }

            const canvasRect = canvas.getBoundingClientRect();
            feedbackElement.style.left = `${canvasRect.left + x}px`;
            feedbackElement.style.top = `${canvasRect.top + y}px`;
            feedbackElement.style.zIndex = 100;

            document.body.appendChild(feedbackElement);

            feedbackElement.addEventListener('animationend', () => {
                feedbackElement.remove();
            });
        }

        function updateStars() {
            const currentTime = Date.now();

            // Spawn new elements (stars, bombs, power-ups)
            if (currentTime - lastStarSpawnTime > starSpawnInterval && gameRunning && !gamePaused) {
                const randomVal = Math.random();
                let type = 'star';
                if (randomVal < 0.15) { // 15% chance for bomb
                    type = 'bomb';
                } else if (randomVal < 0.20) { // 5% chance for power-up (total 20%)
                    type = 'powerup';
                }

                stars.push({
                    x: Math.random() * (canvas.width - 40) + 20,
                    y: -20,
                    size: 30,
                    type: type
                });
                lastStarSpawnTime = currentTime;
            }

            // Move and check elements
            for (let i = stars.length - 1; i >= 0; i--) {
                const item = stars[i];
                item.y += starFallSpeed;

                // Check for collision with catcher
                if (
                    item.y + item.size > catcher.y &&
                    item.x + item.size > catcher.x &&
                    item.x < catcher.x + catcher.width &&
                    item.y < catcher.y + catcher.height
                ) {
                    if (item.type === 'star') {
                        score += 10;
                        scoreDisplay.textContent = score;
                        starCatchSynth.triggerAttackRelease("C5", "8n");
                        showFloatingFeedback(item.x, item.y, '+10', 'positive');
                    } else if (item.type === 'bomb') {
                        if (gameRunning && lives > 0) {
                            lives = Math.max(0, lives - 1); // Ensure lives don't go below 0
                            livesDisplay.textContent = lives;
                            bombHitSynth.triggerAttackRelease("C2", "8n");
                            showFloatingFeedback(item.x, item.y, '-1 Life', 'negative');
                            if (lives === 0) {
                                endGame();
                                return; // Stop processing further items in this frame
                            }
                        }
                    } else if (item.type === 'powerup') {
                        activateMegaCatcher();
                        starCatchSynth.triggerAttackRelease("E6", "8n");
                        showFloatingFeedback(item.x, item.y, 'MEGA CATCHER!', 'positive');
                    }
                    stars.splice(i, 1); // Remove caught item
                } else if (item.y > canvas.height) {
                    // Item missed the catcher and went off-screen
                    if (gameRunning && (item.type === 'star' || item.type === 'powerup')) {
                        if (lives > 0) {
                            lives = Math.max(0, lives - 1); // Ensure lives don't go below 0
                            livesDisplay.textContent = lives;
                            bombHitSynth.triggerAttackRelease("C3", "8n");
                            showFloatingFeedback(item.x, item.y, '-1 Life', 'negative');
                        }
                    }
                    stars.splice(i, 1); // Remove missed item
                    if (gameRunning && lives === 0) {
                        endGame();
                        return;
                    }
                }
            }
        }

        // --- Power-up Logic ---
        function activateMegaCatcher() {
            if (megaCatcherTimeoutId) {
                clearTimeout(megaCatcherTimeoutId);
            }
            catcher.width = catcher.originalWidth * 1.5; // Increase catcher width
            // Ensure catcher stays within bounds after resizing
            if (catcher.x + catcher.width > canvas.width) {
                catcher.x = canvas.width - catcher.width;
            }

            megaCatcherTimeoutId = setTimeout(() => {
                catcher.width = catcher.originalWidth; // Reset to original width
                megaCatcherTimeoutId = null;
            }, megaCatcherDuration);
        }

        // --- Game Loop ---
        function animate() {
            if (!gameRunning || gamePaused) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            updateCatcher();
            updateStars();
            draw();

            animationFrameId = requestAnimationFrame(animate);
        }

        // --- Game State Management ---
        function startGame() {
            // If the game is already running or paused, it's a restart.
            if (gameRunning || gamePaused) {
                resetGame(); // Fully reset the game state
            }
            
            gameRunning = true;
            gamePaused = false; // Game is running, so it's not paused
            hideMessage(); // Hide message box when game starts
            startButton.textContent = 'Restart Game'; // Indicate it's a restart option
            animate(); // Start the animation loop
        }

        function endGame() {
            gameRunning = false;
            gamePaused = true; // Ensure game is paused when over
            cancelAnimationFrame(animationFrameId);
            gameOverSynth.triggerAttackRelease("C3", "1n");
            showMessage(`Game Over! Your final score is: ${score}. Press 'Play Again?' to retry.`);
            // Change the text of the start button to ask to play again
            startButton.textContent = 'Play Again?'; 
        }

        function resetGame() {
            cancelAnimationFrame(animationFrameId); // Stop any ongoing animation
            initGame(); // Reset all game variables and UI to initial state
        }

        // --- Gemini API Integration ---
        async function callGeminiAPI(prompt, successCallback, errorCallback) {
            showMessage("Loading... <span class='loading-spinner'></span>");
            const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = ""; // Canvas will provide this in runtime
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    successCallback(text);
                } else {
                    errorCallback("Failed to get a response from Gemini.");
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                errorCallback("Error fetching data. Please try again.");
            }
        }

        function getEncouragement() {
            const prompt = `Generate a short, encouraging message for a child who is playing a star-catching game. The message should be positive, simple, and congratulate them on their effort or score. Keep it under 20 words. Current score: ${score}.`;
            callGeminiAPI(prompt, (msg) => {
                showMessage(`✨ ${msg}`);
            }, (error) => {
                showMessage(`Error: ${error}`);
            });
        }

        function getStarFact() {
            const prompt = "Generate a very simple and interesting fact about stars or space, suitable for a child. Keep it under 15 words.";
            callGeminiAPI(prompt, (fact) => {
                showMessage(`✨ Did you know? ${fact}`);
            }, (error) => {
                showMessage(`Error: ${error}`);
            });
        }

        // --- Event Listeners ---
        startButton.addEventListener('click', startGame);
        getEncouragementButton.addEventListener('click', getEncouragement);
        getStarFactButton.addEventListener('click', getStarFact);

        catcherSpeedSlider.addEventListener('input', (event) => {
            catcher.speed = parseInt(event.target.value);
        });

        starSpeedSlider.addEventListener('input', (event) => {
            starFallSpeed = parseInt(event.target.value);
        });

        // Keyboard controls for catcher movement
        document.addEventListener('keydown', (e) => {
            if (gameRunning && !gamePaused) { // Movement only if game is running and not paused
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    catcher.dx = -catcher.speed;
                } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    catcher.dx = catcher.speed;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'a' || e.key === 'A' || e.key === 'd' || e.key === 'D') {
                catcher.dx = 0; // Stop movement when key is released
            }
        });

        // --- Touch Controls for Catcher Movement ---
        // This allows touching the left half of the canvas to move left, right half to move right.
        // Touch and hold for continuous movement.
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default touch behavior (like scrolling/zooming)
            if (gameRunning && !gamePaused) {
                const canvasRect = canvas.getBoundingClientRect();
                const touchX = e.touches[0].clientX - canvasRect.left;

                if (touchX < canvas.width / 2) {
                    catcher.dx = -catcher.speed; // Touch left half of canvas
                } else {
                    catcher.dx = catcher.speed; // Touch right half of canvas
                }
            }
        }, { passive: false }); // Use { passive: false } to enable preventDefault

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling during touch-and-hold movement
            if (gameRunning && !gamePaused) {
                const canvasRect = canvas.getBoundingClientRect();
                const touchX = e.touches[0].clientX - canvasRect.left;

                if (touchX < canvas.width / 2) {
                    catcher.dx = -catcher.speed;
                } else {
                    catcher.dx = catcher.speed;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault(); // Prevent default touch behavior
            if (gameRunning && !gamePaused) {
                catcher.dx = 0; // Stop movement when touch ends
            }
        }, { passive: false });
        // --- End Touch Controls ---

        // --- Message Box Functions (for alerts/prompts) ---
        function showMessage(msg) {
            messageBox.innerHTML = msg; // Use innerHTML to allow for spinner
            messageBox.style.display = 'block';
        }

        function hideMessage() {
            messageBox.style.display = 'none';
        }

        // Initial setup on window load
        window.onload = function() {
            setCanvasDimensions();
            initGame(); // Initialize game state
            // Initialize Tone.js synths here to ensure they are available
            starCatchSynth = new Tone.Synth().toDestination();
            bombHitSynth = new Tone.MembraneSynth().toDestination();
            gameOverSynth = new Tone.Synth().toDestination();

            // Start Tone.js context on first user interaction to avoid browser autoplay policy issues
            document.body.addEventListener('click', () => {
                if (!toneStarted) {
                    Tone.start();
                    toneStarted = true;
                }
            }, { once: true });
        };

        window.addEventListener('resize', setCanvasDimensions);
    </script>
</body>
</html>
